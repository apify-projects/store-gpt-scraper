{
    "title": "GPT scraper",
    "type": "object",
    "description": "Crawler scrapers pages and runs GPT model instruction for each page.",
    "schemaVersion": 1,
    "properties": {
        "startUrls": {
            "title": "Start URLs",
            "type": "array",
            "description": "A static list of URLs to scrape. <br><br>For details, see <a href='https://apify.com/drobnikj/gpt-scraper#start-urls' target='_blank' rel='noopener'>Start URLs</a> in README.",
            "prefill": [
                { "url": "https://news.ycombinator.com/" }
            ],
            "editor": "requestListSources"
        },
        "globs": {
            "title": "Glob patterns",
            "type": "array",
            "description": "Glob patterns to match links in the page that you want to enqueue. Combine with Link selector to tell the scraper where to find links. Omitting the Glob patterns will cause the scraper to enqueue all links matched by the Link selector.",
            "editor": "globs",
            "default": [],
            "prefill": []
        },
        "linkSelector": {
            "title": "Link selector",
            "type": "string",
            "description": "A CSS selector saying which links on the page (<code>&lt;a&gt;</code> elements with <code>href</code> attribute) shall be followed and added to the request queue. To filter the links added to the queue, use the <b>Pseudo-URLs</b> setting.<br><br>If <b>Link selector</b> is empty, the page links are ignored.<br><br>For details, see <a href='https://apify.com/drobnikj/gpt-scraper#link-selector' target='_blank' rel='noopener'>Link selector</a> in README.",
            "editor": "textfield",
            "prefill": "a[href]"
        },
        "instructions": {
            "title": "Instructions for GPT",
            "type": "string",
            "description": "Instruct GPT how to generate text. For example: \"Summarize this page into three sentences.\"<br><br>You can instruct to OpenAI to answer with \"skip this page\", which will skip the page. For example: \"Summarize this page into three sentences. If the page is about Apify Proxy answer with 'skip this page'.\".",
            "prefill": "Get from the page the post with the most points and returns it as JSON in format:\npostTitle\npostUrl\npointsCount",
            "editor": "textarea"
        },
        "targetSelector": {
            "title": "Content selector",
            "type": "string",
            "description": "A CSS selector of HTML element on the page will be used in instruction. Istead of whole page you can use only part of the page. For example: \"div#content\".",
            "editor": "textfield",
            "prefill": ""
        },
        "maxCrawlingDepth": {
            "title": "Max crawling depth",
            "type": "integer",
            "description": "Specifies how many links away from <b>Start URLs</b> the scraper will descend. This value is a safeguard against infinite crawling depths for misconfigured scrapers.<br><br>If set to <code>0</code>, there is no limit.",
            "minimum": 0,
            "default": 0
        },
        "maxPagesPerCrawl": {
            "title": "Max pages per run",
            "type": "integer",
            "description": "Maximum number of pages that the scraper will open. 0 means unlimited.",
            "minimum": 0,
            "default": 10,
            "unit": "pages"
        },
        "useStructureOutput": {
            "sectionCaption": "Formatted output",
            "sectionDescription": "By default, the scraper outputs text answers for each page. If you want to get data in a structured format, you can define a JSON schema. The scraper uses [function](https://platform.openai.com/docs/api-reference/chat/create#chat/create-functions), which is called for each page. The function receives the page content and returns the answer in the defined JSON format.",
            "title": "Use JSON schema to format answer",
            "type": "boolean",
            "description": "If true, the answer will be transformed into a structured format based on the schema in the `jsonAnswer` attribute.",
            "editor": "checkbox"
        },
        "schema": {
            "title": "Schema",
            "type": "object",
            "description": "This defines how the output will be stored in structured format using [JSON Schema[JSON Schema](https://json-schema.org/understanding-json-schema/). Keep in mind that it uses [function](https://platform.openai.com/docs/api-reference/chat/create#chat/create-functions), so by setting the description of the fields and the correct title, you can get better results.",
            "prefill": {
                "type": "object",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "Page title"
                    },
                    "description": {
                        "type": "string",
                        "description": "Page description"
                    }
                },
                "required": ["title", "description"]
            },
            "editor": "json"
        },
        "temperature": {
            "sectionCaption": "GPT settings",
            "title": "Temperature",
            "type": "string",
            "description": "Controls randomness: Lowering results in less random completions. As the temperature approaches zero, the model will become deterministic and repetitive. For consistent results, we recommend setting the temperature to 0.",
            "editor": "textfield",
            "default": "0"
        },
        "topP": {
            "title": "TopP",
            "type": "string",
            "description": "Controls diversity via nucleus sampling: 0.5 means half of all likelihood-weighted options are considered.",
            "editor": "textfield",
            "default": "1"
        },
        "frequencyPenalty": {
            "title": "Frequency penalty",
            "type": "string",
            "description": "How much to penalize new tokens based on their existing frequency in the text so far. Decreases the model's likelihood to repeat the same line verbatim.",
            "editor": "textfield",
            "default": "0"
        },
        "presencePenalty": {
            "title": "Presence penalty",
            "type": "string",
            "description": "How much to penalize new tokens based on whether they appear in the text so far. Increases the model's likelihood to talk about new topics.",
            "editor": "textfield",
            "default": "0"
        },
        "pageFormatInRequest": {
            "sectionCaption": "Advanced configuration",
            "title": "Page format in request",
            "type": "string",
            "description": "In what format to send the content extracted from the page to the GPT. Markdown will take less space allowing for larger requests, while HTML may help include some information like attributes that may otherwise be omitted.",
            "enum": ["HTML", "Markdown"],
            "enumTitles": ["HTML", "Markdown"],
            "default": "Markdown"
        },
        "saveSnapshots": {
            "title": "Save debug snapshots",
            "type": "boolean",
            "description": "For each page store its HTML, screenshot and parsed content (markdown/HTML as it was sent to ChatGPT) adding links to these into the output",
            "editor": "checkbox",
            "default": true
        }
    },
    "required": ["startUrls", "instructions" ]
}
